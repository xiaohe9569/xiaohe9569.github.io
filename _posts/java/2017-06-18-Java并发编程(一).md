---
layout: post
title: "Java并发编程(一)"
categories: [Java]
description:
keywords: 并发
---

影响并发操作执行速度的因素有<u>线程创建</u>以及<u>上下文切换</u>

相应的减少上下文切换的方法有：

_1、无锁并发编程：多线程竞争锁会引起上下文切换，可以避免使用锁，如：将数据的id按照hash
算法取模分段，不同的线程处理不同段的数据。_

_2、CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。_

_3、使用最小线程：避免创建不必要的线程_

_4、使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换_

避免死锁：

_1、避免一个线程同时获取多个锁_

_2、尽量保证一个锁只占用一个资源_

_3、尝试使用定时锁,lock.tryLock(timeout)来替代使用内部锁_

_4、数据库锁，加锁和解锁必须在一个数据库连接里_

### 并发底层机制

#### synchronized：
Java中的每一个对象都可以作为锁。锁的三种表现形式：

_1、对于普通同步方法，锁是当前实例对象；_

_2、对于静态同步方法，锁是当前类的class对象；_

_3、对于同步方法块，锁是synchronized括号里配置的对象；_

一个线程访问同步代码块时，必须得到锁；退出或抛出异常时释放锁。

synchronized在JVM中的实现原理：

JVM通过进入和退出Monitor对象来实现方法同步与代码块同步。（Monitorenter/Monitorexit）
Monitorenter指令在编译后插入方法的开始位置，Monitorexit在结束位置或异常位置，成对存在。
任何对象都与一个Monitor与之关联，Monitor被持有后，对象锁定。关系如图：

![对象与对象监视器间的关系](https://raw.githubusercontent.com/xiaohe9569/xiaohe9569.github.io/master/images/20170809141252.png)

synchronized用的锁存在Java对象头里；

Java SE 1.6 锁有四种状态，级别从低到高依次：**无锁状态**、**偏向锁状态**、**轻量级锁状态**、**重量级锁状态**；锁可以升级但不能降级；

偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
线程进入/退出时不需要CAS加锁/解锁，只检查对象头的Mark Word里是否存储着指向当前线程的偏
向锁

**锁的内存定义**
![锁的获取与释放](https://raw.githubusercontent.com/xiaohe9569/xiaohe9569.github.io/master/images/20170807174409.png)
·线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A
对共享变量所做修改的）消息。

·线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共
享变量所做修改的）消息。

·线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发
送消息。

#### volatile：
(轻量级synchronized)在多处理器开发中能保证共享变量的"可见性"，如果一个字段
被声明为volatile,Java线程内存模型确保所有线程看到这个变量的值是一致的;它不会引起上下文
的切换和调度

**volatile特性**

_1、可见性：对一个volatile的读，总是能看到任意线程对其最后的写入_

_2、原子性：对单个volatile的读/写具有原子性，但volatile++复合操作不具有原子性_

jdk5以后，volatile的读/写可以实现线程间通信

volatile的写：JMM会把该线程对应的本地内存中的共享变量值刷新到主内存(写操作完成后会通过主内存向读操作发送消息，)

volatile的读：JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量

volatile仅保证对单个变量的读写具有原子性，而锁的互斥执行特性可保证整个临界区代码的执行具有原子性；功能上锁比volatile更强大，可伸缩性和执行性能上volatile更具优势，所以用时需谨慎。

**锁优缺点对比**
![锁优缺点对比](https://raw.githubusercontent.com/xiaohe9569/xiaohe9569.github.io/master/images/20170728174707.png)

<!-- **final域**
编译器/处理器需要遵循的两个重排序规则：

1、在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用
变量，这两个操作之间不能重排序

2、初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能
重排序

读final域的 **重排序规则** 是：在一个线程中，初次读对象引用与初次读该对象包含的final
域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器） -->
