---
layout: post
title: "Java并发编程(一)"
categories: [Java]
description:
keywords: 并发
---

影响并发操作执行速度的因素有<u>线程创建</u>以及<u>上下文切换</u>

相应的减少上下文切换的方法有：

_1、无锁并发编程：多线程竞争锁会引起上下文切换，可以避免使用锁，如：将数据的id按照hash

算法取模分段，不同的线程处理不同段的数据。_

_2、CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。_

_3、使用最小线程：避免创建不必要的线程_

_4、使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换_

避免死锁：

_1、避免一个线程同时获取多个锁_

_2、尽量保证一个锁只占用一个资源_

_3、尝试使用定时锁,lock.tryLock(timeout)来替代使用内部锁_

_4、数据库锁，加锁和解锁必须在一个数据库连接里_

### 并发底层机制

#### synchronized：
Java中的每一个对象都可以作为锁。锁的三种表现形式：

_1、对于普通同步方法，锁是当前实例对象；_

_2、对于静态同步方法，锁是当前类的class对象；_

_3、对于同步方法块，锁是synchronized括号里配置的对象；_

一个线程访问同步代码块时，必须得到锁；退出或抛出异常时释放锁。

synchronized在JVM中的实现原理：

JVM通过进入和退出Monitor对象来实现方法同步与代码块同步。（Monitorenter/Monitorexit）
Monitorenter指令在编译后插入方法的开始位置，Monitorexit在结束位置或异常位置，成对存在。
任何对象都与一个Monitor与之关联，Monitor被持有后，对象锁定。

synchronized用的锁存在Java对象头里；

Java SE 1.6 锁有四种状态，级别从低到高依次：**无锁状态**、**偏向锁状态**、**轻量级锁状态**、**重量级锁状态**；锁可以升级但不能降级；

偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
线程进入/退出时不需要CAS加锁/解锁，只检查对象头的Mark Word里是否存储着指向当前线程的偏
向锁

#### volatile：
(轻量级synchronized)在多处理器开发中能保证共享变量的"可见性"，如果一个字段
被声明为volatile,Java线程内存模型确保所有线程看到这个变量的值是一致的。

### 锁优缺点对比
![锁优缺点对比](https://raw.githubusercontent.com/xiaohe9569/xiaohe9569.github.io/master/images/20170728174707.png)
