---
layout: post
title: "Java内存模型(JMM)"
categories: [Java]
description: Java内存模型
keywords: Java
---

###引文

并发编程的两个问题：线程间如何通信/线程间如何同步

命令式编程线程间通信的方式有：共享内存/消息传递

共享内存：并发模型中，线程之间共享程序的公共状态，通过写-读内存的公共状态来<u>隐式通信</u>，<u>同步是显示进行的</u>，手动指定线程间互斥执行的代码块

消息传递：线程间发送消息来<u>显示通信</u>，<u>同步是隐式进行的</u>，消息的发送必须在消息的接受之前

### Java内存模型(JMM)

**Java的并发采用的是共享内存模型**

实例域/静态域/数组元素存储在堆内存中，堆内存线程间共享

局部变量/方法定义参数/异常处理参数，线程间不共享，不受JMM影响

JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM模型如图：
![JMM](https://raw.githubusercontent.com/xiaohe9569/xiaohe9569.github.io/master/images/20170731163100.png)

**线程间通信**
如果线程A与线程B之间要通信的话，必须要经历下面2个步骤。

_1、线程A把本地内存A中更新过的共享变量刷新到主内存中去_

_2、线程B到主内存中去读取线程A之前已更新过的共享变量_

JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证

如果程序是正确同步的，程序的执行将具有 **顺序一致性**

未同步程序在JMM中的执行时，JMM只提供最小安全性，(为了实现最小安全性，JVM在堆上分配对象
时，首先会对内存空间进行清零，然后才会在上面分配对象),整体上是无序的。

1、JMM不保证单线程内的操作会按程序的顺序执行(如:正确同步的多线程程序在临界区的重排序)

2、JMM不保证所有线程能看到一致的操作执行顺序

3、JMM不保证对64位的long型和double型变量的写操作具有原子性

### 源码到指令序列的重排序

**重排序**：重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段

**重排序分类**

_1、编译器优化的重排序：不改变单线程语义的情况下，编译器安排语句的执行顺序_

_2、指令级并行（将多条指令重叠执行）的重排序：若不存在数据依赖性，处理器可改变语句对应机器指令的执行顺序_

_3、内存系统的重排序：处理器使用缓存和读/写缓冲区_

源码到最终执行的指令，依次执行1->2->3重排序；
1属于编译器排序，2、3属于处理器排序；可能会导致多线程程序出现内存可见性问题；JMM的编译器重排序规则会禁用部分的编译器重排序，JMM的处理器重排序规则会通过内存屏障指令来禁止特定类型的处理器重排序。

**重排序会遵守数据依赖性**，不会改变存在数据依赖关系的两个操作的执行顺序（单个处理器/单个线程）

**重排序对多线程的影响**

_1、在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果_

**volatile重排序规则**

![volatile重排序](https://raw.githubusercontent.com/xiaohe9569/xiaohe9569.github.io/master/images/20170804105437.png)

这些规则由插入内存屏障来实现

### JMM的设计

**JMM对重排序的应对策略：**

·对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。

·对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求

### 并发编程模型分类

处理器使用写缓冲区临时保存向内存写入的数据，优点：
_1、保证指令流水线持续运行_
_2、通过批处理方式刷新写缓冲区以及合并写缓冲区对同一内存地址的多次写，减少对内存总线的占用_

缺点：
每个处理器上的写缓冲区，仅仅对它所在的处理器可见，造成处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致，<u>故：现代的处理器都会允许对读/写操作进行重排序</u>

### happens-before

要求前一个操作(执行的结果)对后一个操作可见，且前一个操作按顺序排在第二个操作之前
（锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性）

###数据依赖性
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间
就存在 **数据依赖性**

3种类型：写后读/写后写/读后写 (操作重排序，数据结果就会发生变化)

### 总线
**总线事务**：包括读事务(从内存传送数据到处理器)/写事务(从处理器传送数据到内存)

总线会同步试图并发使用总线的事务

![总线的工作机制](https://raw.githubusercontent.com/xiaohe9569/xiaohe9569.github.io/master/images/20170801161139.png)
上图'内存访问A'是总线仲裁的结果，该机制保证在任意时间点最多只能有一个处理器访问内存，这就保证了单个总线事务中的内存读/写操作具有原子性。



32位处理器可能会把一个64位的long/double型变量的写操作拆分成两个32位的写操作来执行，这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。如图
![总线时序图](https://raw.githubusercontent.com/xiaohe9569/xiaohe9569.github.io/master/images/20170803155136.png)
但是jdk5以后仅允许写操作进行上述的拆分，读操作必须具有原子性。只要对上述64位变量声明为volatile,该变量的读写就具有原子性。
